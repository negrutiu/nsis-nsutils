_______________________________________________________________________________

Functions exported by NSutils
[marius.negrutiu@gmail.com]
_______________________________________________________________________________

[GetVersionInfoString]
Extracts a specific string off of an executable's version information block.
Be mindful of the file system redirection on 64-bit platforms!

Syntax:
	NSutils::GetVersionInfoString [/NOUNLOAD] ExeName VersionInfoString

Return value:
	The requested string will be returned on the stack, or an empty string in case of errors...

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms, read from System32 rather than SysWOW64
	NSutils::GetVersionInfoString /NOUNLOAD "$SYSDIR\Notepad.exe" "LegalCopyright"
	Pop $0
	${If} "$0" != ""
		; Valid string
		MessageBox MB_ICONINFORMATION 'LegalCopyright = "$0"'
	${Else}
		; Some error. Probably the string hasn't been found
	${EndIf}
	${EnableX64FSRedirection}
_______________________________________________________________________________

[GetFileVersion]
Extracts the numeric file version off of an executable's version information block.
Be mindful of the file system redirection on 64-bit platforms!

Syntax:
	NSutils::GetFileVersion [/NOUNLOAD] ExeName

Return values:
	If the operation is successful, the function will return a pre-formatted
	"v1.v2.v3.v4" version string on the stack. In addition, $1, $2, $3 and $4
	will store each version component.
	If the operation is unsuccessful, an empty string will be returned on the
	stack and $1..$4 will *not* be set.

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms, read from System32 rather than SysWOW64
	NSutils::GetFileVersion /NOUNLOAD "$SYSDIR\Notepad.exe"
	Pop $0
	${If} "$0" != ""
		; $1, $2, $3, $4 are valid
		MessageBox MB_ICONINFORMATION "FileVersion: $0 ($1, $2, $3, $4)"
	${Else}
		; Error
	${EndIf}
	${EnableX64FSRedirection}
_______________________________________________________________________________

[GetProductVersion]
Extracts the numeric product version off of an executable's version information block.
Be mindful of the file system redirection on 64-bit platforms!

Syntax:
	NSutils::GetProductVersion [/NOUNLOAD] ExeName

Return values:
	If the operation is successful, the function will return a pre-formatted
	"v1.v2.v3.v4" version string on the stack. In addition, $1, $2, $3 and $4
	will store each version component.
	If the operation is unsuccessful, an empty string will be returned on the
	stack and $1..$4 will *not* be set.

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms, read from System32 rather than SysWOW64
	NSutils::GetFileVersion /NOUNLOAD "$SYSDIR\Notepad.exe"
	Pop $0
	${If} "$0" != ""
		; $1, $2, $3, $4 are valid
		MessageBox MB_ICONINFORMATION "ProductVersion: $0 ($1, $2, $3, $4)"
	${Else}
		; Error
	${EndIf}
	${EnableX64FSRedirection}
_______________________________________________________________________________

[ReadResourceString]
Reads the specified string from an executable's string table.
Be mindful of the file system redirection on 64-bit platforms!

Syntax:
	NSutils::ReadResourceString [/NOUNLOAD] ExeName StringID StringLANG

Return values:
	The resource string on the stack.
	An empty string is returned in case of any error.

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms, read from System32 rather than SysWOW64
	NSutils::ReadResourceString /NOUNLOAD "$SYSDIR\Notepad.exe" 14 1033
	Pop $0
	${If} "$0" != ""
		MessageBox MB_ICONINFORMATION 'String #13: "$0"'
	${Else}
		; Error
	${EndIf}
	${EnableX64FSRedirection}
_______________________________________________________________________________

[WriteResourceString]
Writes the specified string to an executable's string table.
If an *empty* string is specified, it will be removed from the string table.

Be mindful of the file system redirection on 64-bit platforms!
Be mindful of the .LN and .mui files (introduced in Vista)!
Executables with sattelite .mui files cannot have their string tables updated!
Read more: "http://msdn.microsoft.com/en-us/library/windows/desktop/ms648049(v=vs.85).aspx"

Syntax:
	NSutils::WriteResourceString [/NOUNLOAD] ExeName StringID StringLANG "The string"

Return values:
	0/1 on the stack

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms
	NSutils::WriteResourceString /NOUNLOAD "$EXEDIR\MyExecutable.exe" 100 1033 "My new string"
	Pop $0
	${If} $0 = ${TRUE}
		MessageBox MB_ICONINFORMATION 'String #100 successfully modified'
	${Else}
		; Error
	${EndIf}
	${EnableX64FSRedirection}
_______________________________________________________________________________

[ExecutePendingFileRenameOperations]
The routine examines the "PendingFileRenameOperations" registry value and
executes the operations on files that match a specified search pattern.
The operations will be removed from the registry value, therefore they won't
be executed during the next reboot...
If not empty, this routine will log all file rename operations to LogFile.

Syntax:
	NSutils::ExecutePendingFileRenameOperations [/NOUNLOAD] "FileSubstring" "LogFile"

Return values:
	Two error codes are returned on the stack.
	1. Win32 error code
	2. Win32 error code of the first failed operation

Example:
	NSutils::ExecutePendingFileRenameOperations [/NOUNLOAD] "AppData\Local\Temp" "C:\MyPath\MyLog.txt"
	Pop $0
	Pop $1
	${If} $0 = ${ERROR_SUCCESS}
		${If} $1 = ${ERROR_SUCCESS}
			; Success. All file operations were successful, as well
		${Else}
			; Success, but some file operations failed...
		${EndIf}
	${Else}
	${EndIf}
_______________________________________________________________________________

[FindPendingFileRenameOperations]
The routine searches the "PendingFileRenameOperations" registry value for
paths containing a specified substring.

Syntax:
	NSutils::FindPendingFileRenameOperations [/NOUNLOAD] "FileSubstring"

Return values:
	[Stack] The first path containing the substring, or, an empty string if nothing is found

Example:
	NSutils::FindPendingFileRenameOperations [/NOUNLOAD] "AppData\Local\Temp"
	Pop $0 ; First path containing the substring
	${If} $0 != ""
		; Path found
	${Else}
		; Nothing found
	${EndIf}
_______________________________________________________________________________

[DisableProgressStepBack]
[RestoreProgressStepBack]
Don't allow the progress bar to step back.
It happens when you have loops in the script.
NSutils must remain loaded between calls, therefore /NOUNLOAD is mandatory!

Syntax:
	NSutils::DisableProgressStepBack /NOUNLOAD ProgressBarHandle
	NSutils::RestoreProgressStepBack [/NOUNLOAD] ProgressBarHandle

Return value:
	None

Example:
	NSutils::DisableProgressStepBack /NOUNLOAD $mui.InstFilesPage.ProgressBar
	${For} $R0 1 10
		Sleep 1000
	${Next}
	NSutils::RestoreProgressStepBack /NOUNLOAD $mui.InstFilesPage.ProgressBar
_______________________________________________________________________________

[RedirectProgressBar]
Redirects the relevant window messages of a progress bar to a second progress bar.
To stop the redirection set ProgressBar2Handle to NULL.
NSutils must remain loaded between calls, therefore /NOUNLOAD is mandatory!

Syntax:
	NSutils::RedirectProgressBar /NOUNLOAD ProgressBarHandle ProgressBar2Handle|NULL

Return value:
	None

Example:
	NSutils::RedirectProgressBar /NOUNLOAD $mui.InstFilesPage.ProgressBar $mui.MyProgressBar
	${For} $R0 1 10
		Sleep 1000
	${Next}
	NSutils::RedirectProgressBar /NOUNLOAD $mui.InstFilesPage.ProgressBar 0
_______________________________________________________________________________

[StartTimer]
[StopTimer]
Starts a timer. A callback is fired each time the clock ticks.
The callback is a regular NSIS function, no input, no output.
NSutils must remain loaded between calls, therefore /NOUNLOAD is mandatory!

Syntax:
	NSutils::StartTimer /NOUNLOAD NsisCallbackFunction TimerPeriodMS
	NSutils::StopTimer [/NOUNLOAD] NsisCallbackFunction

Return values:
	None

Example:
	Function OnMyTimer
		System::Call 'user32::MessageBeep( i 0xffffffff )'
	FunctionEnd
	...
	GetFunctionAddress $0 OnMyTimer
	NSutils::StartTimer /NOUNLOAD $0 1000
	...
	...
	GetFunctionAddress $0 OnMyTimer
	NSutils::StopTimer /NOUNLOAD $0
_______________________________________________________________________________

[StartReceivingClicks]
[StopReceivingClicks]

Subclass a button in order to intercept its BN_CLICKED commands.
A NSIS callback is fired when a child button gets clicked.
The callback function is a regular NSIS function. It receives button's HWND and ID on the stack. No return value.

NSutils must remain loaded between calls, therefore /NOUNLOAD is mandatory!

Syntax:
	NSutils::StartReceivingClicks /NOUNLOAD ButtonParentWnd NsisCallbackFunction
	NSutils::StopReceivingClicks [/NOUNLOAD] ButtonParentWnd

Return values:
	None

Example:
	Function OnButtonClicked
		Pop $1	; Button HWND
		Pop $2	; Button control ID
		MessageBox MB_OK "Clicked button $2"
	FunctionEnd
	...
	GetFunctionAddress $0 OnButtonClicked
	NSutils::StartReceivingClicks /NOUNLOAD $HWNDPARENT $0
	...
	NSutils::StopReceivingClicks /NOUNLOAD $HWNDPARENT
_______________________________________________________________________________

[LoadImageFile]
Loads an image in memory (HBITMAP) using oleaut32!OleLoadPicturePath.
The source can be either a local file, or an URL
Supported formats: BMP, JPEG, GIF

You have to specify the HBITMAP dimensions. The original image will be fitted
within these boundaries according to alignment flags.
AlignH can be "left", "right" or "center"
AlignV can be "top", "bottom" or "center"

[!] When no longer needed you must destroy de HBITMAP by calling user32!DeleteObject

Syntax:
	NSutils::LoadImageFile [/NOUNLOAD] ImageFile|URL Width Height AlignH AlighV

Return values:
	An HBITMAP on the stack

Example:
	NSutils::LoadImageFile "http://www.codeproject.com/App_Themes/CodeProject/Img/logo250x135.gif" 640 480 center center
	Pop $0	; HBITMAP
	...
	System::Call 'user32::DeleteObject( i $0 )'

_______________________________________________________________________________

[RejectCloseMessages]
Reject closing window messages such as WM_CLOSE, WM_DESTROY, WM_COMMAND(IDCANCEL), WM_SYSCOMMAND(SC_CLOSE), etc
All these messages will be blocked regardless of what window they've been sent to

Syntax:
	NSutils::RejectCloseMessages /NOUNLOAD true|false

Return values:
	None

Example:
	NSutils::RejectCloseMessages /NOUNLOAD true
	...
	NSutils::RejectCloseMessages /NOUNLOAD false
_______________________________________________________________________________

[CloseFileHandles]
Close all opened handles to the specified file or folder.
Be mindful of the file system redirection on 64-bit platforms!

Syntax:
	NSutils::ExecutePendingFileRenameOperations [/NOUNLOAD] "File"

Return values:
	The number of closed handles

Example:
	${DisableX64FSRedirection}	; Optional. On 64-bit platforms, read from System32 rather than SysWOW64
	NSutils::CloseFileHandles /NOUNLOAD "$SYSDIR\drivers\etc\hosts"
	${EnableX64FSRedirection}
	Pop $0
	MessageBox MB_OK "$0 handles were closed"
_______________________________________________________________________________

[RegMultiSzInsertBefore]
[RegMultiSzInsertAfter]
[RegMultiSzInsertAtIndex]
Insert a substring to a REG_MULTI_SZ registry value

Syntax:
	NSutils::RegMultiSzInsertBefore  [/NOUNLOAD] "RegKeyName" "RegValueName" KeyFlags "InsertStr" "InsertBeforeStr"
	NSutils::RegMultiSzInsertAfter   [/NOUNLOAD] "RegKeyName" "RegValueName" KeyFlags "InsertStr" "InsertAfterStr"
	NSutils::RegMultiSzInsertAtIndex [/NOUNLOAD] "RegKeyName" "RegValueName" KeyFlags "InsertStr" Index

Return value:
	[Stack] Win32 error

Examples:
	NSutils::RegMultiSzInsertBefore  /NOUNLOAD "HKCU\Software\MyCompany" "MyValue" ${KEY_WOW64_64KEY} "Line 4" "Line 5"
	Pop $0	; Win32 error
	NSutils::RegMultiSzInsertAfter   /NOUNLOAD "HKCU\Software\MyCompany" "MyValue" ${KEY_WOW64_64KEY} "Line 4" "Line 3"
	Pop $0	; Win32 error
	NSutils::RegMultiSzInsertAtIndex /NOUNLOAD "HKCU\Software\MyCompany" "MyValue" ${KEY_WOW64_64KEY} "Line 4" 3
	Pop $0	; Win32 error
_______________________________________________________________________________

[RegMultiSzDelete]
Delete a substring from a REG_MULTI_SZ registry value

Syntax:
	NSutils::RegMultiSzDelete [/NOUNLOAD] "RegKeyName" "RegValueName" KeyFlags "DeleteStr" RemoveValueIfEmpty

Return value:
	[Stack] Win32 error

Example:
	NSutils::RegMultiSzDelete /NOUNLOAD "HKCU\Software\MyCompany" "MyValue" ${KEY_WOW64_64KEY} "Line 4" ${TRUE}
	Pop $0	; Win32 error
_______________________________________________________________________________

[RegMultiSzRead]
Read a substring from a REG_MULTI_SZ registry value

Syntax:
	NSutils::RegMultiSzRead [/NOUNLOAD] "RegKeyName" "RegValueName" KeyFlags Index

Return value:
	[Stack] Win32 error
	[Stack] The substring, or an empty string in case of errors

Example:
	NSutils::RegMultiSzRead /NOUNLOAD "HKCU\Software\MyCompany" "MyValue" ${KEY_WOW64_64KEY} 2
	Pop $0	; Win32 error
	Pop $1	; Substring at index 2
_______________________________________________________________________________

[CPUID]
Retrieve CPU capabilities

Syntax:
	NSutils::CPUID [/NOUNLOAD] FuncId

Return values:
	[Stack] EAX
	[Stack] EBX
	[Stack] ECX
	[Stack] EDX

Example:
	; Check SSE2 availability (Function 1, EDX, bit 26)
	NSutils::CPUID /NOUNLOAD 1
	Pop $1	; EAX
	Pop $2	; EBX
	Pop $3	; ECX
	Pop $4	; EDX
	IntOp $0 $4 & 0x4000000
	${If} $0 <> 0
		DetailPrint "CPU supports SSE2"
	${EndIf}
_______________________________________________________________________________

[CompareFiles]
Test whether two files are identical

Syntax:
	NSutils::CompareFiles [/NOUNLOAD] File1 File2

Return value:
	[Stack] 0/1

Example:
	NSutils::CompareFiles /NOUNLOAD "C:\MyFile1.txt" "C:\MyFile2.txt"
	Pop $0
	${If} $0 = ${TRUE}
		DetailPrint "Files are identical"
	${EndIf}
_______________________________________________________________________________

[RemoveSoftwareRestrictionPolicies]
This routine enumerates software restriction policies and removes the ones that
match a substring.

Syntax:
	NSutils::RemoveSoftwareRestrictionPolicies [/NOUNLOAD] "FileSubstring" "LogFile"

Input:
	[Param] FileSubstring. All policies having this substring in their path will be removed
	[Param] LogFile. Optional

Output:
	[Stack] Win32/HRESULT
	[Stack] Removed policy count

Example:
	NSutils::RemoveSoftwareRestrictionPolicies /NOUNLOAD "MyApp" "$EXEDIR\MyLog.txt"
	Pop $0  ; Error
	Pop $1  ; Removed count
	${If} $0 = 0
		; Success
	${EndIf}
_______________________________________________________________________________
